<!DOCTYPE html>
<html>

<head>
    <title>Why Double?</title>
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: #0f172a;
            color: #f8fafc;
            display: flex;
            justify-content: center;
            padding: 60px 20px;
        }

        .page {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .title {
            text-align: center;
        }

        .container {
            max-width: 800px;
            text-align: justify;
        }

        .math {
            font-family: monospace;
        }

        img {
            width: 100%;
            max-width: 600px;
            height: auto;
            border-radius: 12px;
            margin-bottom: 30px;
        }

        h1 {
            margin-bottom: 20px;
        }

        p {
            opacity: 0.85;
            line-height: 1.6;
        }
    </style>
</head>

<body>
    <div class="page">
        <div class="title">
            <h1>Why Double First?</h1>
            <img src="chart.png" alt="Double vs Estimate Chart">
        </div>
        <div class="container">
            <p>
                The doubling step artificially increases perceived complexity before
                mapping the value to the next Fibonacci number. This models a common
                behavioral bias in estimation: once effort is cognitively expanded,
                teams tend to anchor to a higher bucket.
            </p>
            <p>
                The chart illustrates how doubling creates a steeper growth curve
                compared to the original estimate, before snapping to the next
                Fibonacci step.
            </p>

            <h2>Formal Rationale</h2>

            <p>
                Let <span class="math">F(n)</span> be the selected Fibonacci value. The initial implementation
                computed:
            </p>

            <p class="math">
                min { F(k) | F(k) ≥ 2 · F(n) }
            </p>

            <p>
                That is, it doubled the selected value and then performed a linear search
                over the Fibonacci sequence to find the smallest Fibonacci number greater
                than or equal to that doubled value.
            </p>

            <p>
                However, observing the growth properties of the Fibonacci sequence,
                for the discrete planning set {0,1,2,3,5,8,13,...}, the value closest to
                2·F(n) (when rounding down to the nearest planning bucket) is simply
                F(n+1).
            </p>

            <p>
                Therefore, the loop was algorithmically redundant. The transformation
                can be reduced to:
            </p>

            <p class="math">
                F(n) → F(n+1)
            </p>

            <p>
                In other words, the doubling step is conceptually illustrative,
                but computationally equivalent to advancing one position in the
                Fibonacci sequence.
            </p>
        </div>
    </div>
</body>

</html>